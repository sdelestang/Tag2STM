setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
library(tidyverse)
library(RTMB)
library(dplyr)
library(magrittr)
library(sp)
library(LobFunc)
#devtools::install_github("kassambara/ggpubr")
library(splines)
library(ggpubr)
# Load growth models
source("GrowFunctionsV3.R")
obs <- read.csv("All.growth.data.csv")
head(obs)

## WRL natural mortality for plotting to ~ maximum age (years = 3.5/M)
M <- 0.14

## Why so many release dates missing 
obs %<>% filter(!is.na(Ldate), !is.na(sex)) %>% mutate(Ldays=as.numeric(as.Date(date)-as.Date(Ldate))) %>%  mutate(Lmnth=floor(Ldays/30)) %>% filter(Ldays>0 & floor(Ccl)%in%40:200 & floor(LCl)%in%40:200 & !is.na(Ccl) ) %>%  mutate(growth=Ccl-LCl)  %>% mutate(year=as.year(Ldate), sex=toupper(sex)) %>% filter(sex%in%c('F','M')) %>%  filter(growth>= -1, toupper(Lsex)==toupper(sex))

## Remove duplicated data with a small difference in recapture date
obs %<>% mutate(id=paste(tag,Ldate,dLon,LdLon,Ccl,LCl)) %>% filter(!duplicated(id)) %>% select(-id)

## Add loc  sex Tlbin Tlen Clbin Clen Lmnth num Cbio TlbinLen
## Loc north and south of 30o
obs %<>% mutate(rcloc=1, rlloc=1, rcloc=ifelse(dLat<30,2,1),rlloc=ifelse(LdLat<30,2,1), sex=ifelse(toupper(sex)=='M',2,1), depth=ifelse(is.na(rldepth ), 30,rldepth ))
## Loc north and south of 28o
obs %<>% mutate(rcloc=ifelse(dLat<28,4,rcloc),rlloc=ifelse(LdLat<28,4,rlloc))
## Loc split north into B and A 
obs$rcloc <- ifelse(point.in.polygon(obs$dLon, obs$dLat,  c(113,113.5,114.5,113,113), c(27.5,27.5,29.5,29.5,27.5))==1, 3, obs$rcloc)
obs$rlloc <- ifelse(point.in.polygon(obs$LdLon, obs$LdLat,  c(113,113.5,114.5,113,113), c(27.5,27.5,29.5,29.5,27.5))==1, 3, obs$rlloc)
obs %<>% mutate(rcloc=ifelse(rcloc==3 & depth>=20,4, rcloc), rlloc=ifelse(rcloc==3 & depth>=20,4, rlloc))

## Limit short liberties 
obs %<>% filter(Lmnth>=0)

### Set up timesteps
## Make data frame with date splits
timesteps <- data.frame(month=c(7,11,12,1,3,5), halfmonth=c(0,1,1,1,0,0)) ## This is complex IMuLT WRL
timesteps <- data.frame(month=c(1), halfmonth=c(0)) 
times <- Maketimes(timesteps)

obs %<>% mutate(relmn=as.month(Ldate),relhm=ifelse(as.day(Ldate)>14,1,0), recmn=as.month(date),rechm=ifelse(as.day(date)>14,1,0), relts=times$tstep[match(paste(relmn,relhm),paste(times$month,times$hm))], rects=times$tstep[match(paste(recmn,rechm),paste(times$month,times$hm))], yrslib = as.year(date)-as.year(Ldate), relyr=as.year(Ldate), recyr=as.year(date))

## now determine the number of tsteps at liberty
obs$ntstep <- apply(as.matrix(obs[,c('relyr','recyr','relmn','relhm','recmn','rechm')]), 1, cntTsteps)

## Set up length bins
bins  <- MakeLbin(31, 173, 2)
lbin  <- bins$lbin
lbinL <- bins$lbinL
lbinU <- bins$lbinU

## Now assign length bins
obs %<>% mutate(rccl=Ccl, rlcl=LCl, Tlbin = as.numeric(cut(rlcl, breaks = c(lbinL,(max(lbinL)+30)), include.lowest = T, right = F)), Clbin = as.numeric(cut(rccl, breaks = c(lbinL,(max(lbinL)+30)), include.lowest = T, right = F))) 

## Parameters
ntsteps <- max(times$tstep) ## Year is split into X timesteps in which growth can occur
mxpin <- rep(2,ntsteps)   ## Minimum growth - not always necessary
mnpin <- rep(-10,ntsteps)    ## Maximum growth - smallest lobster
ipin <- rep(80,ntsteps)  ## Inflection point - closely associated with size at maturity
spin_left = rep(log(0.1), ntsteps)   # Steepness for small sizes
spin_right = rep(log(5), ntsteps)  # Steepness for large sizes

s <- 'M'
l <- 1
## Select sex/area first
for(s in c('F','M')){
  for(l in 2:4){
    tdat <- obs %>% filter(Lsex==s,rlloc==l) %>% group_by(Lsex,rlloc,rccl,rlcl,Tlbin,Clbin,relts,rects,ntstep) %>% summarise(rccl=mean(rccl), num=length(Lsex))
    dim(tdat)
    
    pin <- list(
      mxpin=mxpin,mnpin=mnpin,ipin=ipin,spin_left=spin_left,spin_right = spin_right,
      LsigError=log(2),                ## Error for measurement error
      #sigGrow=c(1,0.01),          ## Error for process error    1, 0.01
      sigGrow=c(1),          ## Error for process error    1, 0.01
      MerrorRel=rep(0,nrow(tdat)),   ## Measurement error Release
      LMerrorRelsigma=0,             ## Sigma for above
      MerrorRec=rep(0,nrow(tdat)),   ## Measurement error Recapture
      LMerrorRecsigma=0)             ## Sigma for above  
    
    # tdat$num <- 1
    # Run all combinations of base model to determine the best combination as determined through an iterative basis and using AIC 
    vec <- 1:ntsteps
    totest <- unlist(lapply(1:length(vec), function(i) {combn(vec, i, FUN = function(x) paste(x, collapse = ","), simplify = TRUE)}))  # all possible combinations
    out <- data.frame(id=totest, nLL=NA, AIC=NA, converge=NA) # record various runs
    ## Limit it to 3 timesteps 
    out <- out[apply(as.matrix(out[,1]), 1, nchar)<=4,]
    i <- 1
    for (i in 1:nrow(out)){
      goodts <- as.numeric(strsplit(out$id[i],',')[[1]])
      print(goodts)
      
      ## Matdat## Make Data input 
      datain <- list(Tlbin=tdat$Tlbin, Clbin=tdat$Clbin, Rccl=tdat$rccl, Rlcl=tdat$rlcl, relts=tdat$relts, rcts=tdat$rects, tsteps=as.integer(tdat$ntstep), nlob=tdat$num, nlbin=length(lbin), ntsteps=ntsteps, lbinL=lbinL, lbinU=lbinU, lbin=lbin, goodts=goodts, M=M)
      
      ## Base Model no RE common sigma for measurement error
      map <- Mapfunc(pin); 
      system.time(mod <- MakeADFun(growmod, pin, map=map))
      mout <- nlminb(mod$par, mod$fn, mod$gr, control = list(eval.max=2000, iter.max=2000))
      mout
      
      dout <- mod$rep()
      logLike = sum(dout$LL)
      AIC <-2*length(mout$par)-(2*logLike)
      
      out$nLL[i] <- logLike
      out$AIC[i] <- AIC
      out$converge[i] <- mout$convergence
    }
    
    Fname <- paste(s,l,'new.csv',sep='_')
    out %<>% arrange(AIC)
    write.csv(out, Fname)
  }
}

goodts <- as.numeric(out$id[out$AIC==min(out$AIC)])

s <- 'M'
l <- 1
tdat <- obs %>% filter(Lsex==s,rlloc==l) %>% group_by(Lsex,rlloc,rccl,rlcl,Tlbin,Clbin,relts,rects,ntstep) %>% summarise(rccl=mean(rccl), num=length(Lsex))
dim(tdat)
#goodts <- c(1,6)
## With RE

datain <- list(Tlbin=tdat$Tlbin, Clbin=tdat$Clbin, Rccl=tdat$rccl, Rlcl=tdat$rlcl, relts=tdat$relts, rcts=tdat$rects, tsteps=as.integer(tdat$ntstep), nlob=tdat$num, nlbin=length(lbin), ntsteps=ntsteps, lbinL=lbinL, lbinU=lbinU, lbin=lbin, goodts=goodts, M=M)

map <- Mapfunc(pin,re=T);  #map$LMerrorRelsigma <- map$LMerrorRecsigma <- as.factor(NA)
mod <- MakeADFun(growmod, pin, map=map,random=c("MerrorRel","MerrorRec"))
mout <- nlminb(mod$par, mod$fn, mod$gr, control = list(eval.max=1000, iter.max=1000))
mout

dout <- plotfit()
logLike = sum(dout$LL)
2*length(mout$par)-(2*logLike)


# tmp <-  mod$rep()
# growthmat <- tmp$growthmat[goodts,]
# mx <- ifelse(max(growthmat)>1,max(growthmat),1)
# if(is.matrix(growthmat)){
#   plot(lbin,growthmat[1,],type='l',ylim=c(0,mx),ylab='Increment',xlab='Length bin',main="Growth/Moult")
#   for(i in 2:nrow(growthmat)){ lines(lbin,growthmat[i,],col=i)  }}
# if(!is.matrix(growthmat)){
#   plot(lbin,growthmat,type='l',ylim=c(0,mx),ylab='Increment',xlab='Length bin',main="Growth/Moult")}


# Save the STMs

tsteps <- goodts
for(tt in goodts){
  stm <- mod$report()$stm[,,tt]
  stm[stm<1e-7] <- 0
  Sex <- ifelse(unique(tdat$Lsex)=='F',1,2)
  Fname <- paste0('STM_s',Sex,'_l',unique(tdat$rlloc),'_ts',tt,'.csv')
  print(Fname)
  write.csv(stm,Fname,row.names = F)
}



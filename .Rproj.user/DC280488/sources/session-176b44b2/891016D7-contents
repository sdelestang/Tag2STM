times
timesteps <- data.frame(c(7,11,12,1,3,5), c(0,1,1,1,0,0))
timesteps <- data.frame(month=c(7,11,12,1,3,5), halfmonth=c(0,1,1,1,0,0))
Maketimes(timesteps)
times
obs %<>% mutate(relmn=as.month(Ldate),relhm=ifelse(as.day(Ldate)>14,1,0), recmn=as.month(date),rechm=ifelse(as.day(date)>14,1,0), relts=times$tstep[match(paste(relmn,relhm),paste(times$month,times$hm))], rects=times$tstep[match(paste(recmn,rechm),paste(times$month,times$hm))], yrslib = as.year(date)-as.year(Ldate), relyr=as.year(Ldate), recyr=as.year(date))
obs
ntsteps<- 6
tstepsvec <- c(4:ntsteps,rep(1:ntsteps,100))[1:20]
tstepsvec
## now determine the number of tsteps at liberty
obs$ntstep <- apply(as.matrix(obs[,c('relyr','recyr','relts','rects')]), 1, funcnts, mt=max(times$tstep))
obs
Maketimes <- function(x){
library(dplyr)
library(tidyr)
# template
tmp <- expand.grid(month = 1:12, hm = 0:1) %>%
arrange(month, hm) %>%
mutate(tstep = NA_integer_)
# map tstep from x onto template
tmp$tstep <- x[match(
paste(tmp$month, tmp$hm),
paste(x[[1]], x[[2]])
), 3]
# ---- fill missing tstep, circular ----
tmp <- tmp %>%
mutate(
tstep = if_else(
is.na(tstep) & row_number() < which(!is.na(tstep))[1],
last(na.omit(tstep)),
tstep
)
) %>%
fill(tstep)
# ---- identify continuous runs ----
tmp <- tmp %>%
mutate(run_id = cumsum(tstep != lag(tstep, default = first(tstep))))
# ---- assign fractional weight per run ----
tmp <- tmp %>%
group_by(run_id, tstep) %>%
mutate(tfrac = 1 / n()) %>%
ungroup() %>%
select(-run_id)
return(tmp)
}
times <- Maketimes(timesteps)
Maketimes <- function(x){
x$tstep <- 1:nrow(x)
library(dplyr)
library(tidyr)
# template
tmp <- expand.grid(month = 1:12, hm = 0:1) %>%
arrange(month, hm) %>%
mutate(tstep = NA_integer_)
# map tstep from x onto template
tmp$tstep <- x[match(
paste(tmp$month, tmp$hm),
paste(x[[1]], x[[2]])
), 3]
# ---- fill missing tstep, circular ----
tmp <- tmp %>%
mutate(
tstep = if_else(
is.na(tstep) & row_number() < which(!is.na(tstep))[1],
last(na.omit(tstep)),
tstep
)
) %>%
fill(tstep)
# ---- identify continuous runs ----
tmp <- tmp %>%
mutate(run_id = cumsum(tstep != lag(tstep, default = first(tstep))))
# ---- assign fractional weight per run ----
tmp <- tmp %>%
group_by(run_id, tstep) %>%
mutate(tfrac = 1 / n()) %>%
ungroup() %>%
select(-run_id)
return(tmp)
}
times <- Maketimes(timesteps)
Maketimes
Maketimes <- function(x){
x$tstep <- 1:nrow(x)
library(dplyr)
library(tidyr)
# template
tmp <- expand.grid(month = 1:12, hm = 0:1) %>%
arrange(month, hm) %>%
mutate(tstep = NA_integer_)
# map tstep from x onto template
tmp$tstep <- x[match(
paste(tmp$month, tmp$hm),
paste(x[[1]], x[[2]])
), 3]
# ---- fill missing tstep, circular ----
tmp <- tmp %>%
mutate(
tstep = if_else(
is.na(tstep) & row_number() < which(!is.na(tstep))[1],
last(na.omit(tstep)),
tstep
)
) %>%
fill(tstep)
# ---- identify continuous runs ----
tmp <- tmp %>%
mutate(run_id = cumsum(tstep != lag(tstep, default = first(tstep))))
# ---- assign fractional weight per run ----
tmp <- tmp %>%
group_by(run_id, tstep) %>%
mutate(tfrac = 1 / n()) %>%
ungroup() %>%
select(-run_id)
return(tmp)
}
Maketimes
times <- Maketimes(timesteps)
times
as.data.frame(times)
Maketimes <- function(x){
x$tstep <- 1:nrow(x)
library(dplyr)
library(tidyr)
# template
tmp <- expand.grid(month = 1:12, hm = 0:1) %>%
arrange(month, hm) %>%
mutate(tstep = NA_integer_)
# map tstep from x onto template
tmp$tstep <- x[match(
paste(tmp$month, tmp$hm),
paste(x[[1]], x[[2]])
), 3]
# ---- fill missing tstep, circular ----
tmp <- tmp %>%
mutate(
tstep = if_else(
is.na(tstep) & row_number() < which(!is.na(tstep))[1],
last(na.omit(tstep)),
tstep
)
) %>%
fill(tstep)
# ---- fractional allocation per timestep ----
tmp <- tmp %>%
group_by(tstep) %>%
mutate(tfrac = 1 / n()) %>%
ungroup()
return(tmp)
}
times <- Maketimes(timesteps)
times
times
obs %<>% mutate(relmn=as.month(Ldate),relhm=ifelse(as.day(Ldate)>14,1,0), recmn=as.month(date),rechm=ifelse(as.day(date)>14,1,0), relts=times$tstep[match(paste(relmn,relhm),paste(times$month,times$hm))], rects=times$tstep[match(paste(recmn,rechm),paste(times$month,times$hm))], yrslib = as.year(date)-as.year(Ldate), relyr=as.year(Ldate), recyr=as.year(date))
head(obs)
funcnts
xx <- obs[1:10,c('relyr','recyr','relts','rects')]
xx
head(obs)
xx <- obs[1:10,c('relyr','recyr','relmn' 'relhm' 'recmn' 'rechm')]
xx <- obs[1:10,c('relyr','recyr','relmn','relhm','recmn','rechm')]
xx
x <- x[1,]
x
xx <- obs[1:10,c('relyr','recyr','relmn','relhm','recmn','rechm')]
x <- xx[1,]
x
nyrs <- x[2]-x[1]
nyrs
x[4]
times
times <- as.data.frame(times)
times
Maketimes <- function(x){
x$tstep <- 1:nrow(x)
library(dplyr)
library(tidyr)
# template
tmp <- expand.grid(month = 1:12, hm = 0:1) %>%
arrange(month, hm) %>%
mutate(tstep = NA_integer_)
# map tstep from x onto template
tmp$tstep <- x[match(
paste(tmp$month, tmp$hm),
paste(x[[1]], x[[2]])
), 3]
# ---- fill missing tstep, circular ----
tmp <- tmp %>%
mutate(
tstep = if_else(
is.na(tstep) & row_number() < which(!is.na(tstep))[1],
last(na.omit(tstep)),
tstep
)
) %>%
fill(tstep)
# ---- fractional allocation per timestep ----
tmp <- tmp %>%
group_by(tstep) %>%
mutate(tfrac = 1 / n()) %>%
ungroup()
tmp %<>% mutate(id=paste(month,hm))
return(tmp)
}
times <- Maketimes(timesteps)
times
stime <- times[match(paste(x[3],x[4]), times$id)]
stime <- times[match(paste(x[3],x[4]), times$id),]
stime
etime <- times[match(paste(x[5],x[6]), times$id),]
etime
stime
x
nyrs
spos <- which(match(paste(x[3],x[4]), times$id))
match(paste(x[3],x[4]), times$id)
epos <- match(paste(x[5],x[6]), times$id)
epos
times$tfrac
nrow(times)
spos:nrow(times)
spos <- match(paste(x[3],x[4]), times$id)
epos <- match(paste(x[5],x[6]), times$id)
spos:nrow(times)
times$tfrac[spos:nrow(times)]
if(nyrs>0) { Tfrac <- sum(times$tfrac[spos:nrow(times)]) + ((nyrs-1) * sum(times$tfrac[1:nrow(times)])) + sum(times$tfrac[1:epos])}
Tfrac
times$tfrac[spos:nrow(times)]
(nyrs-1)
times$tfrac[1:nrow(times)]
sum(times$tfrac[1:nrow(times)])
times$tfrac[1:epos]
sum(times$tfrac[1:epos])
sum(times$tfrac[1:epos])
((nyrs-1) * sum(times$tfrac[1:nrow(times)])) + sum(times$tfrac[1:epos])
times$tfrac[spos:nrow(times)
]
Tfrac
x
toXL(times)
head(obs)
round(1.5,0)
round(1.4,0)
cntTsteps <- function(x){
nyrs <- x[2]-x[1]
spos <- match(paste(x[3],x[4]), times$id)
epos <- match(paste(x[5],x[6]), times$id)
if(nyrs==0) Tfrac <- sum(times$tfrac[spos:epos])
if(nyrs>0) { Tfrac <- sum(times$tfrac[spos:nrow(times)]) + ((nyrs-1) * sum(times$tfrac[1:nrow(times)])) + sum(times$tfrac[1:epos])}
Tfrac <- round(Tfrac,0)
return(Tfrac)}
## now determine the number of tsteps at liberty
obs$ntstep <- apply(as.matrix(obs[,c('relyr','recyr','relts','rects')]), 1, funcnts, mt=max(times$tstep))
obs$ntstep2 <- apply(as.matrix(obs[,c('relyr','recyr','relmn','relhm','recmn','rechm', 'ntstep')]), 1, cntTsteps)
head(obs)
x <- xx[4,]
x
x
times
as.data.frame(times)
timesteps <- data.frame(month=c(1), halfmonth=c(0))
timesteps
times <- Maketimes(timesteps)
times
obs$ntstep2 <- apply(as.matrix(obs[,c('relyr','recyr','relmn','relhm','recmn','rechm', 'ntstep')]), 1, cntTsteps)
head(obs)
## now determine the number of tsteps at liberty
obs$ntstep <- apply(as.matrix(obs[,c('relyr','recyr','relmn','relhm','recmn','rechm', 'ntstep')]), 1, cntTsteps)
MakeLbin <- function(start, stop, gap = 2){
lbinU <- seq(start, stop, gap)
lbinL <- lbinU - gap
lbin  <- rowMeans(cbind(lbinU, lbinL))
lbinL[1] <- lbinL[1] - 20
lbinU[length(lbinU)] <- lbinU[length(lbinU)] + 20
return(list(lbin  = lbin, lbinL = lbinL,lbinU = lbinU ))
}
## Set up length bins
list(lbin, lbinL, lbinU) <- MakeLbin(31,173,2)
MakeLbin(31,173,2)
## Set up length bins
list(lbin, lbinL, lbinU) <- MakeLbin(31,173,2)
bins  <- MakeLbin(31, 173, 2)
lbin  <- bins$lbin
lbinL <- bins$lbinL
lbinU <- bins$lbinU
lbinU
## Now assign length bins
obs %<>% mutate(rccl=Ccl, rlcl=LCl, Tlbin = as.numeric(cut(rlcl, breaks = c(lbinL,(max(lbinL)+30)), include.lowest = T, right = F)), Clbin = as.numeric(cut(rccl, breaks = c(lbinL,(max(lbinL)+30)), include.lowest = T, right = F)))
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
library(tidyverse)
library(RTMB)
library(dplyr)
library(magrittr)
library(sp)
library(LobFunc)
#devtools::install_github("kassambara/ggpubr")
library(splines)
library(ggpubr)
# Load growth models
source("GrowFunctionsV3.R")
obs <- read.csv("All.growth.data.csv")
head(obs)
## WRL natural mortality for plotting to ~ maximum age (years = 3.5/M)
M <- 0.14
## Why so many release dates missing
obs %<>% filter(!is.na(Ldate), !is.na(sex)) %>% mutate(Ldays=as.numeric(as.Date(date)-as.Date(Ldate))) %>%  mutate(Lmnth=floor(Ldays/30)) %>% filter(Ldays>0 & floor(Ccl)%in%40:200 & floor(LCl)%in%40:200 & !is.na(Ccl) ) %>%  mutate(growth=Ccl-LCl)  %>% mutate(year=as.year(Ldate), sex=toupper(sex)) %>% filter(sex%in%c('F','M')) %>%  filter(growth>= -1, toupper(Lsex)==toupper(sex))
## Remove duplicated data with a small difference in recapture date
obs %<>% mutate(id=paste(tag,Ldate,dLon,LdLon,Ccl,LCl)) %>% filter(!duplicated(id)) %>% select(-id)
## Add loc  sex Tlbin Tlen Clbin Clen Lmnth num Cbio TlbinLen
## Loc north and south of 30o
obs %<>% mutate(rcloc=1, rlloc=1, rcloc=ifelse(dLat<30,2,1),rlloc=ifelse(LdLat<30,2,1), sex=ifelse(toupper(sex)=='M',2,1), depth=ifelse(is.na(rldepth ), 30,rldepth ))
## Loc north and south of 28o
obs %<>% mutate(rcloc=ifelse(dLat<28,4,rcloc),rlloc=ifelse(LdLat<28,4,rlloc))
## Loc split north into B and A
obs$rcloc <- ifelse(point.in.polygon(obs$dLon, obs$dLat,  c(113,113.5,114.5,113,113), c(27.5,27.5,29.5,29.5,27.5))==1, 3, obs$rcloc)
obs$rlloc <- ifelse(point.in.polygon(obs$LdLon, obs$LdLat,  c(113,113.5,114.5,113,113), c(27.5,27.5,29.5,29.5,27.5))==1, 3, obs$rlloc)
obs %<>% mutate(rcloc=ifelse(rcloc==3 & depth>=20,4, rcloc), rlloc=ifelse(rcloc==3 & depth>=20,4, rlloc))
## Limit short liberties
obs %<>% filter(Lmnth>=0)
### Set up timesteps
## Make data frame with date splits
timesteps <- data.frame(month=c(7,11,12,1,3,5), halfmonth=c(0,1,1,1,0,0)) ## This is complex IMuLT WRL
#timesteps <- data.frame(month=c(1), halfmonth=c(0))
times <- Maketimes(timesteps)
obs %<>% mutate(relmn=as.month(Ldate),relhm=ifelse(as.day(Ldate)>14,1,0), recmn=as.month(date),rechm=ifelse(as.day(date)>14,1,0), relts=times$tstep[match(paste(relmn,relhm),paste(times$month,times$hm))], rects=times$tstep[match(paste(recmn,rechm),paste(times$month,times$hm))], yrslib = as.year(date)-as.year(Ldate), relyr=as.year(Ldate), recyr=as.year(date))
## now determine the number of tsteps at liberty
obs$ntstep <- apply(as.matrix(obs[,c('relyr','recyr','relmn','relhm','recmn','rechm', 'ntstep')]), 1, cntTsteps)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
library(tidyverse)
library(RTMB)
library(dplyr)
library(magrittr)
library(sp)
library(LobFunc)
#devtools::install_github("kassambara/ggpubr")
library(splines)
library(ggpubr)
# Load growth models
source("GrowFunctionsV3.R")
obs <- read.csv("All.growth.data.csv")
head(obs)
## WRL natural mortality for plotting to ~ maximum age (years = 3.5/M)
M <- 0.14
## Why so many release dates missing
obs %<>% filter(!is.na(Ldate), !is.na(sex)) %>% mutate(Ldays=as.numeric(as.Date(date)-as.Date(Ldate))) %>%  mutate(Lmnth=floor(Ldays/30)) %>% filter(Ldays>0 & floor(Ccl)%in%40:200 & floor(LCl)%in%40:200 & !is.na(Ccl) ) %>%  mutate(growth=Ccl-LCl)  %>% mutate(year=as.year(Ldate), sex=toupper(sex)) %>% filter(sex%in%c('F','M')) %>%  filter(growth>= -1, toupper(Lsex)==toupper(sex))
## Remove duplicated data with a small difference in recapture date
obs %<>% mutate(id=paste(tag,Ldate,dLon,LdLon,Ccl,LCl)) %>% filter(!duplicated(id)) %>% select(-id)
## Add loc  sex Tlbin Tlen Clbin Clen Lmnth num Cbio TlbinLen
## Loc north and south of 30o
obs %<>% mutate(rcloc=1, rlloc=1, rcloc=ifelse(dLat<30,2,1),rlloc=ifelse(LdLat<30,2,1), sex=ifelse(toupper(sex)=='M',2,1), depth=ifelse(is.na(rldepth ), 30,rldepth ))
## Loc north and south of 28o
obs %<>% mutate(rcloc=ifelse(dLat<28,4,rcloc),rlloc=ifelse(LdLat<28,4,rlloc))
## Loc split north into B and A
obs$rcloc <- ifelse(point.in.polygon(obs$dLon, obs$dLat,  c(113,113.5,114.5,113,113), c(27.5,27.5,29.5,29.5,27.5))==1, 3, obs$rcloc)
obs$rlloc <- ifelse(point.in.polygon(obs$LdLon, obs$LdLat,  c(113,113.5,114.5,113,113), c(27.5,27.5,29.5,29.5,27.5))==1, 3, obs$rlloc)
obs %<>% mutate(rcloc=ifelse(rcloc==3 & depth>=20,4, rcloc), rlloc=ifelse(rcloc==3 & depth>=20,4, rlloc))
## Limit short liberties
obs %<>% filter(Lmnth>=0)
### Set up timesteps
## Make data frame with date splits
timesteps <- data.frame(month=c(7,11,12,1,3,5), halfmonth=c(0,1,1,1,0,0)) ## This is complex IMuLT WRL
timesteps
times <- Maketimes(timesteps)
times
timesteps
obs %<>% mutate(relmn=as.month(Ldate),relhm=ifelse(as.day(Ldate)>14,1,0), recmn=as.month(date),rechm=ifelse(as.day(date)>14,1,0), relts=times$tstep[match(paste(relmn,relhm),paste(times$month,times$hm))], rects=times$tstep[match(paste(recmn,rechm),paste(times$month,times$hm))], yrslib = as.year(date)-as.year(Ldate), relyr=as.year(Ldate), recyr=as.year(date))
## now determine the number of tsteps at liberty
obs$ntstep <- apply(as.matrix(obs[,c('relyr','recyr','relts','rects')]), 1, funcnts, mt=max(times$tstep))
## Set up length bins
gap <- 2
lbinU <- seq(31,173,gap)
lbinL <- lbinU-gap
lbin <- apply(cbind(lbinU,lbinL),1, mean)
lbinL[1] <- lbinL[1] - 20
lbinU[length(lbinU)] <- lbinU[length(lbinU)] + 20
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
library(tidyverse)
library(RTMB)
library(dplyr)
library(magrittr)
library(sp)
library(LobFunc)
#devtools::install_github("kassambara/ggpubr")
library(splines)
library(ggpubr)
# Load growth models
source("GrowFunctionsV3.R")
obs <- read.csv("All.growth.data.csv")
head(obs)
## WRL natural mortality for plotting to ~ maximum age (years = 3.5/M)
M <- 0.14
## Why so many release dates missing
obs %<>% filter(!is.na(Ldate), !is.na(sex)) %>% mutate(Ldays=as.numeric(as.Date(date)-as.Date(Ldate))) %>%  mutate(Lmnth=floor(Ldays/30)) %>% filter(Ldays>0 & floor(Ccl)%in%40:200 & floor(LCl)%in%40:200 & !is.na(Ccl) ) %>%  mutate(growth=Ccl-LCl)  %>% mutate(year=as.year(Ldate), sex=toupper(sex)) %>% filter(sex%in%c('F','M')) %>%  filter(growth>= -1, toupper(Lsex)==toupper(sex))
## Remove duplicated data with a small difference in recapture date
obs %<>% mutate(id=paste(tag,Ldate,dLon,LdLon,Ccl,LCl)) %>% filter(!duplicated(id)) %>% select(-id)
## Add loc  sex Tlbin Tlen Clbin Clen Lmnth num Cbio TlbinLen
## Loc north and south of 30o
obs %<>% mutate(rcloc=1, rlloc=1, rcloc=ifelse(dLat<30,2,1),rlloc=ifelse(LdLat<30,2,1), sex=ifelse(toupper(sex)=='M',2,1), depth=ifelse(is.na(rldepth ), 30,rldepth ))
## Loc north and south of 28o
obs %<>% mutate(rcloc=ifelse(dLat<28,4,rcloc),rlloc=ifelse(LdLat<28,4,rlloc))
## Loc split north into B and A
obs$rcloc <- ifelse(point.in.polygon(obs$dLon, obs$dLat,  c(113,113.5,114.5,113,113), c(27.5,27.5,29.5,29.5,27.5))==1, 3, obs$rcloc)
obs$rlloc <- ifelse(point.in.polygon(obs$LdLon, obs$LdLat,  c(113,113.5,114.5,113,113), c(27.5,27.5,29.5,29.5,27.5))==1, 3, obs$rlloc)
obs %<>% mutate(rcloc=ifelse(rcloc==3 & depth>=20,4, rcloc), rlloc=ifelse(rcloc==3 & depth>=20,4, rlloc))
## Limit short liberties
obs %<>% filter(Lmnth>=0)
### Set up timesteps
## Make data frame with date splits
timesteps <- data.frame(month=c(7,11,12,1,3,5), halfmonth=c(0,1,1,1,0,0)) ## This is complex IMuLT WRL
#timesteps <- data.frame(month=c(1), halfmonth=c(0))
times <- Maketimes(timesteps)
times
obs %<>% mutate(relmn=as.month(Ldate),relhm=ifelse(as.day(Ldate)>14,1,0), recmn=as.month(date),rechm=ifelse(as.day(date)>14,1,0), relts=times$tstep[match(paste(relmn,relhm),paste(times$month,times$hm))], rects=times$tstep[match(paste(recmn,rechm),paste(times$month,times$hm))], yrslib = as.year(date)-as.year(Ldate), relyr=as.year(Ldate), recyr=as.year(date))
## now determine the number of tsteps at liberty
obs$ntstep <- apply(as.matrix(obs[,c('relyr','recyr','relmn','relhm','recmn','rechm', 'ntstep')]), 1, cntTsteps)
cntTsteps
as.matrix(obs[,c('relyr','recyr','relmn','relhm','recmn','rechm', 'ntstep')])
## now determine the number of tsteps at liberty
obs$ntstep <- apply(as.matrix(obs[,c('relyr','recyr','relmn','relhm','recmn','rechm')]), 1, cntTsteps)
## Set up length bins
bins  <- MakeLbin(31, 173, 2)
lbin  <- bins$lbin
lbinL <- bins$lbinL
lbinU <- bins$lbinU
## Now assign length bins
obs %<>% mutate(rccl=Ccl, rlcl=LCl, Tlbin = as.numeric(cut(rlcl, breaks = c(lbinL,(max(lbinL)+30)), include.lowest = T, right = F)), Clbin = as.numeric(cut(rccl, breaks = c(lbinL,(max(lbinL)+30)), include.lowest = T, right = F)))
## Parameters
ntsteps <- max(times$tstep) ## Year is split into X timesteps in which growth can occur
ntsteps
mxpin <- rep(2,ntsteps)   ## Minimum growth - not always necessary
mnpin <- rep(-10,ntsteps)    ## Maximum growth - smallest lobster
ipin <- rep(80,ntsteps)  ## Inflection point - closely associated with size at maturity
spin_left = rep(log(0.1), ntsteps)   # Steepness for small sizes
spin_right = rep(log(5), ntsteps)  # Steepness for large sizes
s <- 'M'
l <- 1
tdat <- obs %>% filter(Lsex==s,rlloc==l) %>% group_by(Lsex,rlloc,rccl,rlcl,Tlbin,Clbin,relts,rects,ntstep) %>% summarise(rccl=mean(rccl), num=length(Lsex))
dim(tdat)
pin <- list(
mxpin=mxpin,mnpin=mnpin,ipin=ipin,spin_left=spin_left,spin_right = spin_right,#,spin=spin
LsigError=log(2),                ## Error for measurement error
#sigGrow=c(1,0.01),          ## Error for process error    1, 0.01
sigGrow=c(1),          ## Error for process error    1, 0.01
MerrorRel=rep(0,nrow(tdat)),   ## Measurement error Release
LMerrorRelsigma=0,             ## Sigma for above
MerrorRec=rep(0,nrow(tdat)),   ## Measurement error Recapture
LMerrorRecsigma=0)             ## Sigma for above
# tdat$num <- 1
# Run all combinations of base model to determine the best combination as determined through an iterative basis and using AIC
vec <- 1:ntsteps
totest <- unlist(lapply(1:length(vec), function(i) {combn(vec, i, FUN = function(x) paste(x, collapse = ","), simplify = TRUE)}))  # all possible combinations
out <- data.frame(id=totest, nLL=NA, AIC=NA, converge=NA) # record various runs
## Limit it to 3 timesteps
out <- out[apply(as.matrix(out[,1]), 1, nchar)<=4,]
i <- 1
goodts <- as.numeric(strsplit(out$id[i],',')[[1]])
print(goodts)
## Matdat## Make Data input
datain <- list(Tlbin=tdat$Tlbin, Clbin=tdat$Clbin, Rccl=tdat$rccl, Rlcl=tdat$rlcl, relts=tdat$relts, rcts=tdat$rects, tsteps=as.integer(tdat$ntstep), nlob=tdat$num, nlbin=length(lbin), ntsteps=ntsteps, lbinL=lbinL, lbinU=lbinU, lbin=lbin, goodts=goodts, M=M)
## Base Model no RE common sigma for measurement error
map <- Mapfunc(pin);
system.time(mod <- MakeADFun(growmod, pin, map=map))
mout <- nlminb(mod$par, mod$fn, mod$gr, control = list(eval.max=2000, iter.max=2000))
mout
dout <- mod$rep()
logLike = sum(dout$LL)
AIC <-2*length(mout$par)-(2*logLike)
dout <- plotfit()
logLike
AIC
logLike = -sum(dout$LL)
AIC <-2*length(mout$par)-(2*logLike)
AIC
logLike = sum(dout$LL)
timesteps <- data.frame(month=c(1), halfmonth=c(0))
times <- Maketimes(timesteps)
obs %<>% mutate(relmn=as.month(Ldate),relhm=ifelse(as.day(Ldate)>14,1,0), recmn=as.month(date),rechm=ifelse(as.day(date)>14,1,0), relts=times$tstep[match(paste(relmn,relhm),paste(times$month,times$hm))], rects=times$tstep[match(paste(recmn,rechm),paste(times$month,times$hm))], yrslib = as.year(date)-as.year(Ldate), relyr=as.year(Ldate), recyr=as.year(date))
## now determine the number of tsteps at liberty
obs$ntstep <- apply(as.matrix(obs[,c('relyr','recyr','relmn','relhm','recmn','rechm')]), 1, cntTsteps)
## Now assign length bins
obs %<>% mutate(rccl=Ccl, rlcl=LCl, Tlbin = as.numeric(cut(rlcl, breaks = c(lbinL,(max(lbinL)+30)), include.lowest = T, right = F)), Clbin = as.numeric(cut(rccl, breaks = c(lbinL,(max(lbinL)+30)), include.lowest = T, right = F)))
## Parameters
ntsteps <- max(times$tstep) ## Year is split into X timesteps in which growth can occur
mxpin <- rep(2,ntsteps)   ## Minimum growth - not always necessary
mnpin <- rep(-10,ntsteps)    ## Maximum growth - smallest lobster
ipin <- rep(80,ntsteps)  ## Inflection point - closely associated with size at maturity
spin_left = rep(log(0.1), ntsteps)   # Steepness for small sizes
spin_right = rep(log(5), ntsteps)  # Steepness for large sizes
s <- 'M'
l <- 1
tdat <- obs %>% filter(Lsex==s,rlloc==l) %>% group_by(Lsex,rlloc,rccl,rlcl,Tlbin,Clbin,relts,rects,ntstep) %>% summarise(rccl=mean(rccl), num=length(Lsex))
dim(tdat)
pin <- list(
mxpin=mxpin,mnpin=mnpin,ipin=ipin,spin_left=spin_left,spin_right = spin_right,
LsigError=log(2),                ## Error for measurement error
#sigGrow=c(1,0.01),          ## Error for process error    1, 0.01
sigGrow=c(1),          ## Error for process error    1, 0.01
MerrorRel=rep(0,nrow(tdat)),   ## Measurement error Release
LMerrorRelsigma=0,             ## Sigma for above
MerrorRec=rep(0,nrow(tdat)),   ## Measurement error Recapture
LMerrorRecsigma=0)             ## Sigma for above
## Matdat## Make Data input
datain <- list(Tlbin=tdat$Tlbin, Clbin=tdat$Clbin, Rccl=tdat$rccl, Rlcl=tdat$rlcl, relts=tdat$relts, rcts=tdat$rects, tsteps=as.integer(tdat$ntstep), nlob=tdat$num, nlbin=length(lbin), ntsteps=ntsteps, lbinL=lbinL, lbinU=lbinU, lbin=lbin, goodts=goodts, M=M)
## Base Model no RE common sigma for measurement error
map <- Mapfunc(pin);
system.time(mod <- MakeADFun(growmod, pin, map=map))
mout <- nlminb(mod$par, mod$fn, mod$gr, control = list(eval.max=2000, iter.max=2000))
mout
dout <- plotfit()
